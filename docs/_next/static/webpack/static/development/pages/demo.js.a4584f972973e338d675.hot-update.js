webpackHotUpdate("static/development/pages/demo.js",{

/***/ "../flowjv/dist/jsonflow/blocks/object.js":
/*!************************************************!*\
  !*** ../flowjv/dist/jsonflow/blocks/object.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.execObjectFlow = void 0;\nvar jsonlogic_1 = __webpack_require__(/*! ../../jsonlogic */ \"../flowjv/dist/jsonlogic/index.js\");\nvar get_1 = __importDefault(__webpack_require__(/*! lodash/get */ \"../../node_modules/lodash/get.js\"));\nvar unset_1 = __importDefault(__webpack_require__(/*! lodash/unset */ \"../../node_modules/lodash/unset.js\"));\nvar flowatoms_1 = __webpack_require__(/*! ./flowatoms */ \"../flowjv/dist/jsonflow/blocks/flowatoms/index.js\");\nexports.execObjectFlow = function (flow, data, flowContext, options) {\n    var e_1, _a, e_2, _b;\n    var _c;\n    var properties = flow.properties;\n    var errorStore = { errors: [], isValid: true };\n    try {\n        for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {\n            var config = properties_1_1.value;\n            if (config.type === \"switch\") {\n                var cond = jsonlogic_1.execJSONExpression(config.cond, data);\n                try {\n                    for (var _d = (e_2 = void 0, __values(Object.keys(config.cases))), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var v = _e.value;\n                        if (v !== cond) {\n                            config.cases[v].forEach(function (prop) { return unset_1.default(data.data, __spread(flowContext.refPath, [prop.key])); });\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                var flow_1 = config.cases[cond];\n                if (flow_1) {\n                    var result = exports.execObjectFlow({ type: \"object\", properties: flow_1 }, data, flowContext, options);\n                    if (!result.isValid) {\n                        if (options === null || options === void 0 ? void 0 : options.aggressive) {\n                            errorStore = {\n                                isValid: false,\n                                errors: __spread(errorStore.errors, result.errors),\n                            };\n                        }\n                        else {\n                            return result;\n                        }\n                    }\n                }\n                continue;\n            }\n            if (config.type === \"if\") {\n                var cond = !!jsonlogic_1.execJSONExpression(config.cond, data);\n                if (options === null || options === void 0 ? void 0 : options.enforceSchema) {\n                    if (cond) {\n                        // delete false fields.\n                        (_c = config.false) === null || _c === void 0 ? void 0 : _c.forEach(function (v) {\n                            unset_1.default(data.data, __spread(flowContext.refPath, [v.key]).join(\".\"));\n                        });\n                    }\n                    else {\n                        // delete true fields.\n                        config.true.forEach(function (v) {\n                            unset_1.default(data.data, __spread(flowContext.refPath, [v.key]).join(\".\"));\n                        });\n                    }\n                }\n                var flow_2 = cond ? config.true : config.false;\n                if (flow_2) {\n                    var result = exports.execObjectFlow({ type: \"object\", properties: flow_2 }, data, flowContext, options);\n                    if (!result.isValid) {\n                        if (options === null || options === void 0 ? void 0 : options.aggressive) {\n                            errorStore = {\n                                isValid: false,\n                                errors: __spread(errorStore.errors, result.errors),\n                            };\n                        }\n                        else {\n                            return result;\n                        }\n                    }\n                }\n                continue;\n            }\n            var ignoreKey = config.ignoreKey, key = config.key;\n            if (ignoreKey) {\n                var ignore = !!jsonlogic_1.execJSONExpression(ignoreKey, data);\n                if (ignore)\n                    continue;\n            }\n            var refPath = __spread(flowContext.refPath, [key]);\n            switch (config.type) {\n                case \"object\": {\n                    return exports.execObjectFlow(config, data, __assign(__assign({}, flowContext), { refPath: refPath }));\n                }\n                // Default specifies a primitive value type!\n                default: {\n                    var result = flowatoms_1.execPrimitiveFlow(config, __assign(__assign({}, data), { ref: get_1.default(data.data, key) }), __assign(__assign({}, flowContext), { refPath: refPath }));\n                    if (!result.isValid) {\n                        if (options === null || options === void 0 ? void 0 : options.aggressive) {\n                            // If aggressive, collect all errors!\n                            errorStore = {\n                                isValid: false,\n                                errors: __spread(errorStore.errors, result.errors),\n                            };\n                            continue;\n                        }\n                        return result;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return errorStore;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZmxvd2p2L2Rpc3QvanNvbmZsb3cvYmxvY2tzL29iamVjdC5qcz82MzFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMERBQWlCO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLG9EQUFZO0FBQ2hELDhCQUE4QixtQkFBTyxDQUFDLHdEQUFjO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsMkZBQTJGLHNCQUFzQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxVQUFVO0FBQ2hIO0FBQ0E7QUFDQSxxRUFBcUUsOEVBQThFLEVBQUU7QUFDcko7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUNBQXFDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFDQUFxQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlCQUFpQixtQkFBbUI7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFVBQVUscUNBQXFDLHVCQUF1QixpQkFBaUIsbUJBQW1CO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vZmxvd2p2L2Rpc3QvanNvbmZsb3cvYmxvY2tzL29iamVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4ZWNPYmplY3RGbG93ID0gdm9pZCAwO1xudmFyIGpzb25sb2dpY18xID0gcmVxdWlyZShcIi4uLy4uL2pzb25sb2dpY1wiKTtcbnZhciBnZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dldFwiKSk7XG52YXIgdW5zZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3Vuc2V0XCIpKTtcbnZhciBmbG93YXRvbXNfMSA9IHJlcXVpcmUoXCIuL2Zsb3dhdG9tc1wiKTtcbmV4cG9ydHMuZXhlY09iamVjdEZsb3cgPSBmdW5jdGlvbiAoZmxvdywgZGF0YSwgZmxvd0NvbnRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICB2YXIgX2M7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBmbG93LnByb3BlcnRpZXM7XG4gICAgdmFyIGVycm9yU3RvcmUgPSB7IGVycm9yczogW10sIGlzVmFsaWQ6IHRydWUgfTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0aWVzXzEgPSBfX3ZhbHVlcyhwcm9wZXJ0aWVzKSwgcHJvcGVydGllc18xXzEgPSBwcm9wZXJ0aWVzXzEubmV4dCgpOyAhcHJvcGVydGllc18xXzEuZG9uZTsgcHJvcGVydGllc18xXzEgPSBwcm9wZXJ0aWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gcHJvcGVydGllc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnR5cGUgPT09IFwic3dpdGNoXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZCA9IGpzb25sb2dpY18xLmV4ZWNKU09ORXhwcmVzc2lvbihjb25maWcuY29uZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyhPYmplY3Qua2V5cyhjb25maWcuY2FzZXMpKSksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gX2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jYXNlc1t2XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiB1bnNldF8xLmRlZmF1bHQoZGF0YS5kYXRhLCBfX3NwcmVhZChmbG93Q29udGV4dC5yZWZQYXRoLCBbcHJvcC5rZXldKSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9iID0gX2QucmV0dXJuKSkgX2IuY2FsbChfZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmxvd18xID0gY29uZmlnLmNhc2VzW2NvbmRdO1xuICAgICAgICAgICAgICAgIGlmIChmbG93XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuZXhlY09iamVjdEZsb3coeyB0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiBmbG93XzEgfSwgZGF0YSwgZmxvd0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclN0b3JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBfX3NwcmVhZChlcnJvclN0b3JlLmVycm9ycywgcmVzdWx0LmVycm9ycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLnR5cGUgPT09IFwiaWZcIikge1xuICAgICAgICAgICAgICAgIHZhciBjb25kID0gISFqc29ubG9naWNfMS5leGVjSlNPTkV4cHJlc3Npb24oY29uZmlnLmNvbmQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW5mb3JjZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGZhbHNlIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IGNvbmZpZy5mYWxzZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNldF8xLmRlZmF1bHQoZGF0YS5kYXRhLCBfX3NwcmVhZChmbG93Q29udGV4dC5yZWZQYXRoLCBbdi5rZXldKS5qb2luKFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0cnVlIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50cnVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNldF8xLmRlZmF1bHQoZGF0YS5kYXRhLCBfX3NwcmVhZChmbG93Q29udGV4dC5yZWZQYXRoLCBbdi5rZXldKS5qb2luKFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmxvd18yID0gY29uZCA/IGNvbmZpZy50cnVlIDogY29uZmlnLmZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChmbG93XzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuZXhlY09iamVjdEZsb3coeyB0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiBmbG93XzIgfSwgZGF0YSwgZmxvd0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclN0b3JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBfX3NwcmVhZChlcnJvclN0b3JlLmVycm9ycywgcmVzdWx0LmVycm9ycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWdub3JlS2V5ID0gY29uZmlnLmlnbm9yZUtleSwga2V5ID0gY29uZmlnLmtleTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlID0gISFqc29ubG9naWNfMS5leGVjSlNPTkV4cHJlc3Npb24oaWdub3JlS2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWZQYXRoID0gX19zcHJlYWQoZmxvd0NvbnRleHQucmVmUGF0aCwgW2tleV0pO1xuICAgICAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5leGVjT2JqZWN0Rmxvdyhjb25maWcsIGRhdGEsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbG93Q29udGV4dCksIHsgcmVmUGF0aDogcmVmUGF0aCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgc3BlY2lmaWVzIGEgcHJpbWl0aXZlIHZhbHVlIHR5cGUhXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmxvd2F0b21zXzEuZXhlY1ByaW1pdGl2ZUZsb3coY29uZmlnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgcmVmOiBnZXRfMS5kZWZhdWx0KGRhdGEuZGF0YSwga2V5KSB9KSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGZsb3dDb250ZXh0KSwgeyByZWZQYXRoOiByZWZQYXRoIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hZ2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWdncmVzc2l2ZSwgY29sbGVjdCBhbGwgZXJyb3JzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3RvcmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IF9fc3ByZWFkKGVycm9yU3RvcmUuZXJyb3JzLCByZXN1bHQuZXJyb3JzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzXzFfMSAmJiAhcHJvcGVydGllc18xXzEuZG9uZSAmJiAoX2EgPSBwcm9wZXJ0aWVzXzEucmV0dXJuKSkgX2EuY2FsbChwcm9wZXJ0aWVzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yU3RvcmU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../flowjv/dist/jsonflow/blocks/object.js\n");

/***/ })

})